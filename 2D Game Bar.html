<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Typing Attack</title>
    <style>
        body {
            margin: 0;
            background: #000;
            overflow: hidden; /* Prevent scrollbars */
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let soundsEnabled = true;
        let running = true;

        // Responsive resize
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Game states
        const STATES = { MENU: 'menu', PLAYING: 'playing', PAUSED: 'paused', GAMEOVER: 'gameover' };
        let state = STATES.MENU;

        // Difficulty settings
        const DIFFICULTIES = {
            EASY: { speed: 0.5, wordLength: [2, 4], spawnRate: 3000 },
            NORMAL: { speed: 2, wordLength: [5, 8], spawnRate: 1500 },
            EXPERT: { speed: 3, wordLength: [8, 12], spawnRate: 1000 }
        };
        let difficulty = 'EASY';

        // Word list
        const allWords = 'a,abandon,ability,able,about,above,abroad,absence,absolute,absorb,abuse,accept,access,accident,accompany,accomplish,account,accurate,accuse,achieve,acid,acknowledge,acquire,across,act,action,active,activity,actor,actress,actual,add,address,adjust,admire,adopt,adult,advance,advantage,advice,affair,affect,afford,afraid,after,afternoon,again,against,age,agency,agent,agree,agreement,ago,air,airport,alarm,album,alive,allow,almost,alone,along,already,also,although,always,amazing,among,amount,analysis,ancient,and,anger,animal,answer,anxiety,any,anyone,anything,anyway,apart,apartment,apple,apply,appoint,approach,approval,approve,area,argue,army,around,arrange,arrest,arrive,art,artist,as,ask,aspect,assault,assist,assume,at,athlete,attack,attempt,attend,attention,attitude,attract,audience,author,available,avoid,award,aware,baby,back,bad,bag,balance,ball,bank,bar,base,baseball,basic,basket,bath,battle,be,beach,bear,beat,beautiful,because,become,bed,beer,before,begin,behavior,behind,being,belief,believe,bell,belong,below,best,better,between,beyond,big,bike,bill,bird,birth,bit,black,blade,blame,blanket,blind,block,blood,blue,board,boat,body,bone,book,boom,boss,both,bottle,bottom,bowl,box,boy,brain,branch,brand,bread,break,breakfast,breath,bridge,bright,bring,broad,broken,brother,brown,brush,build,building,burn,business,but,buy,by'.split(',');

        function getWordsByLength(min, max) {
            return allWords.filter(w => w.length >= min && w.length <= max);
        }

        // Game variables
        let player = { x: canvas.width / 2, y: canvas.height - 50, health: 5 };
        let enemies = [];
        let particles = [];
        let lasers = [];
        let stars = [];
        let score = 0;
        let typed = '';
        let targetedEnemy = null;
        let lastSpawn = 0;
        let startTime = null;
        let wordsDestroyed = 0;
        let totalCorrectChars = 0;
        let errorCount = 0;

        for (let i = 0; i < 100; i++) {
            stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: Math.random() * 2 + 1 });
        }

        // Sounds
        function playSound(freq, duration, type = 'sine') {
            if (!soundsEnabled) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.value = freq;
            osc.type = type;
            osc.start();
            gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.stop(audioCtx.currentTime + duration);
        }
        function playShoot() { playSound(800, 0.1, 'square'); }
        function playExplosion() { playSound(100, 0.3, 'sawtooth'); }
        function playWrong() { playSound(200, 0.1, 'triangle'); }

        function getRandomWord(minLen, maxLen) {
            const filtered = getWordsByLength(minLen, maxLen);
            return filtered[Math.floor(Math.random() * filtered.length)] || 'word';
        }

        // Enemy class
        class Enemy {
            constructor(x, y, word, speed) {
                this.x = x;
                this.y = y;
                this.word = word.toLowerCase();
                this.speed = speed;
                this.size = 30;
            }
            update() {
                this.y += this.speed;
                if (this.y > canvas.height - 50) {
                    player.health--;
                    enemies = enemies.filter(e => e !== this);
                    if (this === targetedEnemy) {
                        typed = '';
                        targetedEnemy = null;
                    }
                    if (player.health <= 0) state = STATES.GAMEOVER;
                }
            }
            draw() {
                ctx.shadowColor = this === targetedEnemy ? '#00ff00' : '#ff00ff';
                ctx.shadowBlur = this === targetedEnemy ? 20 : 15;

                // Draw cartoon character sprite (simple alien)
                ctx.fillStyle = this === targetedEnemy ? '#00ff00' : '#ff00ff';
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.size, this.size * 0.8, 0, 0, Math.PI * 2); // Oval head
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.x - this.size / 3, this.y - this.size / 4, this.size / 6, 0, Math.PI * 2);
                ctx.arc(this.x + this.size / 3, this.y - this.size / 4, this.size / 6, 0, Math.PI * 2);
                ctx.fill();

                // Pupils
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(this.x - this.size / 3, this.y - this.size / 4, this.size / 12, 0, Math.PI * 2);
                ctx.arc(this.x + this.size / 3, this.y - this.size / 4, this.size / 12, 0, Math.PI * 2);
                ctx.fill();

                // Mouth
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y + this.size / 4, this.size / 4, 0, Math.PI);
                ctx.stroke();

                ctx.shadowBlur = 0;

                // Draw text overlay with contrast
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                const textY = this.y - this.size - 5;
                const textWidth = ctx.measureText(this.word).width;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(this.x - textWidth / 2 - 5, textY - 15, textWidth + 10, 20);

                if (this === targetedEnemy) {
                    // Dim full word
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.fillText(this.word, this.x, textY);

                    // Bright typed prefix overlay
                    const prefix = typed;
                    const prefixWidth = ctx.measureText(prefix).width;
                    const fullWidth = textWidth;
                    const startX = this.x - fullWidth / 2;
                    ctx.fillStyle = '#00ff00';
                    ctx.fillText(prefix, startX + prefixWidth / 2, textY);
                } else {
                    // Normal word
                    ctx.fillStyle = '#fff';
                    ctx.fillText(this.word, this.x, textY);
                }
            }
        }

        class Particle {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.vx = Math.random() * 4 - 2;
                this.vy = Math.random() * 4 - 2;
                this.life = 20;
                this.color = '#ff00ff';
            }
            update() { this.x += this.vx; this.y += this.vy; this.life--; }
            draw() { ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, 2, 2); }
        }

        class Laser {
            constructor(sx, sy, ex, ey) {
                this.startX = sx; this.startY = sy;
                this.endX = ex; this.endY = ey;
                this.life = 10;
            }
            update() { this.life--; }
            draw() {
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.startX, this.startY);
                ctx.lineTo(this.endX, this.endY);
                ctx.stroke();
            }
        }

        function drawStars() {
            ctx.fillStyle = '#fff';
            stars.forEach(s => ctx.fillRect(s.x, s.y, s.size, s.size));
        }

        function drawPlayer() {
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.moveTo(player.x, player.y - 30);
            ctx.lineTo(player.x - 25, player.y + 20);
            ctx.lineTo(player.x + 25, player.y + 20);
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function spawnEnemy() {
            const config = DIFFICULTIES[difficulty];
            const x = Math.random() * (canvas.width - 100) + 50;
            const word = getRandomWord(...config.wordLength);
            enemies.push(new Enemy(x, 0, word, config.speed));
        }

        // Typing
        window.addEventListener('keydown', (e) => {
            if (state === STATES.PAUSED && e.key === 'Escape') { state = STATES.PLAYING; return; }
            if (state !== STATES.PLAYING) return;
            if (e.key === 'Escape') { state = STATES.PAUSED; return; }
            const key = e.key.toLowerCase();
            if (key.length === 1 && key.match(/[a-z]/)) {
                if (!startTime) startTime = Date.now();
                typed += key; 
                
                // Create laser effect for each keystroke when targeting an enemy
                if (targetedEnemy) {
                    playShoot();
                    lasers.push(new Laser(player.x, player.y - 30, targetedEnemy.x, targetedEnemy.y));
                }
                
                checkMatch();
            } else if (e.key === 'Backspace') {
                typed = typed.slice(0, -1); checkMatch();
            }
        });

        function checkMatch() {
            if (targetedEnemy) {
                if (!targetedEnemy.word.startsWith(typed)) {
                    errorCount++; typed = ''; targetedEnemy = null; playWrong(); checkMatch();
                } else if (typed === targetedEnemy.word) {
                    // Automatically destroy enemy when word is fully typed
                    handleEnemyDestroyed(targetedEnemy);
                }
                return;
            }
            const targets = enemies.filter(e => e.word.startsWith(typed));
            if (targets.length > 0) {
                targets.sort((a, b) => b.y - a.y);
                targetedEnemy = targets[0];
            } else { playWrong(); errorCount++; typed = ''; }
        }

        function handleEnemyDestroyed(enemy) {
            // No need to create a laser here since we're already creating lasers on each keystroke
            setTimeout(() => {
                if (soundsEnabled) playExplosion();
                for (let i = 0; i < 10; i++) particles.push(new Particle(enemy.x, enemy.y));
            }, 100);
            enemies = enemies.filter(e => e !== enemy);
            totalCorrectChars += typed.length;
            wordsDestroyed++; 
            // Award more points based on word length and difficulty
            const wordBonus = enemy.word.length * 5;
            const difficultyMultiplier = difficulty === 'EASY' ? 1 : (difficulty === 'NORMAL' ? 2 : 3);
            score += (10 + wordBonus) * difficultyMultiplier;
            typed = ''; targetedEnemy = null;
        }

        // Pause button object
        let pauseButton = {
            x: canvas.width - 60,
            y: 60,
            radius: 20,
            draw: function() {
                // Draw button circle
                ctx.fillStyle = '#ff9900';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw pause icon
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x - 7, this.y - 10, 5, 20);
                ctx.fillRect(this.x + 2, this.y - 10, 5, 20);
                
                // Add outline
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
            },
            isClicked: function(x, y) {
                const distance = Math.sqrt(Math.pow(x - this.x, 2) + Math.pow(y - this.y, 2));
                return distance <= this.radius;
            }
        };

        function drawHUD() {
            // Draw score with highlight
            ctx.fillStyle = '#00ffff'; ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'left'; 
            ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 10;
            ctx.fillText(Score: ${score}, 20, 30);
            ctx.shadowBlur = 0;
            
            // Draw health
            ctx.fillStyle = '#fff'; ctx.font = '20px Arial';
            ctx.textAlign = 'right'; ctx.fillText(Health: ${player.health}, canvas.width - 20, 30);
            
            // Draw typed text
            ctx.textAlign = 'center'; ctx.fillText(Typed: ${typed}, canvas.width / 2, canvas.height - 20);
            
            // Draw pause button
            pauseButton.x = canvas.width - 60; // Update position in case of window resize
            pauseButton.draw();
        }

        // BUTTON SYSTEM
        function drawButton(text, x, y, mode, isHovered) {
            const w = 300, h = 40;
            const bx = x - w / 2, by = y - h / 2;
            ctx.fillStyle = isHovered ? "#ffaa33" : "#ff9900";
            ctx.fillRect(bx, by, w, h);
            ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.strokeRect(bx, by, w, h);
            ctx.fillStyle = "#000"; ctx.font = "20px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(text, x, y);
            return { x: bx, y: by, width: w, height: h, mode };
        }

        let menuButtons = [];
        let pauseButtons = [];
        let gameoverButtons = [];
        let mousePos = null;
        canvas.addEventListener("mousemove", e => {
            const r = canvas.getBoundingClientRect();
            mousePos = { x: e.clientX - r.left, y: e.clientY - r.top };
        });

        function drawMenu() {
            drawStars();
            ctx.fillStyle = '#00ffff'; ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 20;
            ctx.font = '60px Arial'; ctx.textAlign = 'center';
            ctx.fillText('TYPING ATTACK', canvas.width / 2, canvas.height / 2 - 150);
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#fff'; ctx.font = '30px Arial';
            ctx.fillText('Type to Survive!', canvas.width / 2, canvas.height / 2 - 90);

            menuButtons = [];
            const hoveredEasy = mousePos && mousePos.y > canvas.height/2 - 40 && mousePos.y < canvas.height/2;
            const hoveredNormal = mousePos && mousePos.y > canvas.height/2 + 20 && mousePos.y < canvas.height/2 + 60;
            const hoveredExpert = mousePos && mousePos.y > canvas.height/2 + 80 && mousePos.y < canvas.height/2 + 120;
            const hoveredClose = mousePos && mousePos.y > canvas.height/2 + 140 && mousePos.y < canvas.height/2 + 180;
            menuButtons.push(drawButton("Play Easy Mode", canvas.width / 2, canvas.height / 2 - 20, "EASY", hoveredEasy));
            menuButtons.push(drawButton("Play Normal Mode", canvas.width / 2, canvas.height / 2 + 40, "NORMAL", hoveredNormal));
            menuButtons.push(drawButton("Play Expert Mode", canvas.width / 2, canvas.height / 2 + 100, "EXPERT", hoveredExpert));
            menuButtons.push(drawButton("Close Game", canvas.width / 2, canvas.height / 2 + 160, "CLOSE", hoveredClose));

            ctx.font = '16px Arial'; ctx.fillStyle = '#fff';
            ctx.fillText("Created by 2D Game Bar", canvas.width / 2, canvas.height - 30);
        }

        function handleClick(e) {
            const r = canvas.getBoundingClientRect();
            const x = (e.clientX || e.touches[0].clientX) - r.left;
            const y = (e.clientY || e.touches[0].clientY) - r.top;
            
            // Check if pause button was clicked during gameplay
            if (state === STATES.PLAYING && pauseButton.isClicked(x, y)) {
                state = STATES.PAUSED;
                return;
            }
            
            if (state === STATES.MENU) {
                for (let btn of menuButtons) {
                    if (x > btn.x && x < btn.x + btn.width && y > btn.y && y < btn.y + btn.height) {
                        if (btn.mode === "CLOSE") {
                            running = false;
                            canvas.style.display = 'none';
                        } else {
                            difficulty = btn.mode; 
                            startGame();
                        }
                    }
                }
            } else if (state === STATES.PAUSED) {
                for (let btn of pauseButtons) {
                    if (x > btn.x && x < btn.x + btn.width && y > btn.y && y < btn.y + btn.height) {
                        if (btn.mode === "RESUME") {
                            state = STATES.PLAYING;
                        } else if (btn.mode === "MENU") {
                            state = STATES.MENU;
                        } else if (btn.mode === "CLOSE") {
                            running = false;
                            canvas.style.display = 'none';
                        }
                    }
                }
            } else if (state === STATES.GAMEOVER) {
                for (let btn of gameoverButtons) {
                    if (x > btn.x && x < btn.x + btn.width && y > btn.y && y < btn.y + btn.height) {
                        if (btn.mode === "MENU") {
                            state = STATES.MENU;
                        } else if (btn.mode === "CLOSE") {
                            running = false;
                            canvas.style.display = 'none';
                        }
                    }
                }
            }
        }
        canvas.addEventListener('click', handleClick);

        function startGame() {
            state = STATES.PLAYING;
            player.health = 5; score = 0;
            enemies = []; particles = []; lasers = [];
            typed = ''; targetedEnemy = null; lastSpawn = 0;
            startTime = null; wordsDestroyed = 0; totalCorrectChars = 0; errorCount = 0;
        }

        function drawPaused() {
            ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0,0,canvas.width,canvas.height);
            
            // Pause title with glow effect
            ctx.fillStyle = '#00ffff'; 
            ctx.shadowColor = '#00ffff'; 
            ctx.shadowBlur = 15;
            ctx.font = '50px Arial'; 
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', canvas.width/2, canvas.height/2 - 80);
            ctx.shadowBlur = 0;
            
            // Draw pause menu buttons
            pauseButtons = [];
            const hoveredResume = mousePos && mousePos.y > canvas.height/2 - 20 && mousePos.y < canvas.height/2 + 20;
            const hoveredMenu = mousePos && mousePos.y > canvas.height/2 + 40 && mousePos.y < canvas.height/2 + 80;
            const hoveredClose = mousePos && mousePos.y > canvas.height/2 + 100 && mousePos.y < canvas.height/2 + 140;
            pauseButtons.push(drawButton("Resume Game", canvas.width/2, canvas.height/2, "RESUME", hoveredResume));
            pauseButtons.push(drawButton("Return to Menu", canvas.width/2, canvas.height/2 + 60, "MENU", hoveredMenu));
            pauseButtons.push(drawButton("Close Game", canvas.width/2, canvas.height/2 + 120, "CLOSE", hoveredClose));
        }

        function drawGameOver() {
            drawStars();
            ctx.fillStyle = '#fff'; ctx.font = '50px Arial'; ctx.textAlign = 'center';
            ctx.fillText('Game Over', canvas.width/2, canvas.height/2-100);
            ctx.font = '30px Arial';
            ctx.fillText(Final Score: ${score}, canvas.width/2, canvas.height/2-30);
            let acc = 0, wpm = 0;
            if (startTime) {
                const total = totalCorrectChars + errorCount;
                acc = total > 0 ? Math.round(totalCorrectChars / total * 100) : 0;
                const minutes = (Date.now()-startTime)/60000;
                wpm = minutes > 0 ? Math.round(wordsDestroyed/minutes) : 0;
            }
            ctx.fillText(Accuracy: ${acc}%, canvas.width/2, canvas.height/2+10);
            ctx.fillText(Words Per Minute: ${wpm}, canvas.width/2, canvas.height/2+50);

            gameoverButtons = [];
            const hoveredMenu = mousePos && mousePos.y > canvas.height/2 + 100 && mousePos.y < canvas.height/2 + 140;
            const hoveredClose = mousePos && mousePos.y > canvas.height/2 + 160 && mousePos.y < canvas.height/2 + 200;
            gameoverButtons.push(drawButton("Return to Menu", canvas.width/2, canvas.height/2+120, "MENU", hoveredMenu));
            gameoverButtons.push(drawButton("Close Game", canvas.width/2, canvas.height/2+180, "CLOSE", hoveredClose));
        }

        function gameLoop(ts) {
            if (!running) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                return;
            }
            ctx.clearRect(0,0,canvas.width,canvas.height);
            drawStars();
            if (state === STATES.PLAYING) {
                const cfg = DIFFICULTIES[difficulty];
                if (ts-lastSpawn > cfg.spawnRate) { spawnEnemy(); lastSpawn = ts; }
                enemies.forEach(e => { e.update(); e.draw(); });
                particles = particles.filter(p=>p.life>0); particles.forEach(p=>{p.update();p.draw();});
                lasers = lasers.filter(l=>l.life>0); lasers.forEach(l=>{l.update();l.draw();});
                drawPlayer(); drawHUD();
            } else if (state === STATES.MENU) drawMenu();
            else if (state === STATES.PAUSED) { enemies.forEach(e=>e.draw()); drawPlayer(); drawHUD(); drawPaused(); }
            else if (state === STATES.GAMEOVER) drawGameOver();
            requestAnimationFrame(gameLoop);
        }
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>